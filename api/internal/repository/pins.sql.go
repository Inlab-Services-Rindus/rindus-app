// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pins.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPin = `-- name: CreatePin :one
INSERT INTO pins (
    event_date,
    image_pin,
    pin_title,
    pin_description,
    auto_assigned,
    category_id,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
)
RETURNING id, event_date, image_pin, pin_title, pin_description, auto_assigned, category_id, deleted_at, created_at, updated_at
`

type CreatePinParams struct {
	EventDate      pgtype.Date
	ImagePin       string
	PinTitle       string
	PinDescription string
	AutoAssigned   pgtype.Bool
	CategoryID     int32
}

func (q *Queries) CreatePin(ctx context.Context, arg CreatePinParams) (Pin, error) {
	row := q.db.QueryRow(ctx, createPin,
		arg.EventDate,
		arg.ImagePin,
		arg.PinTitle,
		arg.PinDescription,
		arg.AutoAssigned,
		arg.CategoryID,
	)
	var i Pin
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.ImagePin,
		&i.PinTitle,
		&i.PinDescription,
		&i.AutoAssigned,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPinCategory = `-- name: CreatePinCategory :one
INSERT INTO pins_category (
    name,
    created_at,
    updated_at
) VALUES (
    $1,
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP
)
RETURNING id, name, deleted_at, created_at, updated_at
`

func (q *Queries) CreatePinCategory(ctx context.Context, name string) (PinsCategory, error) {
	row := q.db.QueryRow(ctx, createPinCategory, name)
	var i PinsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllEmployeePins = `-- name: GetAllEmployeePins :many
SELECT employee_id, pin_id, category_id, deleted_at, created_at, updated_at FROM employee_pins WHERE deleted_at IS NULL
`

func (q *Queries) GetAllEmployeePins(ctx context.Context) ([]EmployeePin, error) {
	rows, err := q.db.Query(ctx, getAllEmployeePins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeePin
	for rows.Next() {
		var i EmployeePin
		if err := rows.Scan(
			&i.EmployeeID,
			&i.PinID,
			&i.CategoryID,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeePinsByEmployeeID = `-- name: GetEmployeePinsByEmployeeID :many
SELECT employee_id, pin_id, category_id, deleted_at, created_at, updated_at FROM employee_pins WHERE employee_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetEmployeePinsByEmployeeID(ctx context.Context, employeeID int32) ([]EmployeePin, error) {
	rows, err := q.db.Query(ctx, getEmployeePinsByEmployeeID, employeeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeePin
	for rows.Next() {
		var i EmployeePin
		if err := rows.Scan(
			&i.EmployeeID,
			&i.PinID,
			&i.CategoryID,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeePinsByPinID = `-- name: GetEmployeePinsByPinID :many
SELECT employee_id, pin_id, category_id, deleted_at, created_at, updated_at FROM employee_pins WHERE pin_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetEmployeePinsByPinID(ctx context.Context, pinID int32) ([]EmployeePin, error) {
	rows, err := q.db.Query(ctx, getEmployeePinsByPinID, pinID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EmployeePin
	for rows.Next() {
		var i EmployeePin
		if err := rows.Scan(
			&i.EmployeeID,
			&i.PinID,
			&i.CategoryID,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPinByID = `-- name: GetPinByID :one
SELECT id, event_date, image_pin, pin_title, pin_description, auto_assigned, category_id, deleted_at, created_at, updated_at FROM pins WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPinByID(ctx context.Context, id int32) (Pin, error) {
	row := q.db.QueryRow(ctx, getPinByID, id)
	var i Pin
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.ImagePin,
		&i.PinTitle,
		&i.PinDescription,
		&i.AutoAssigned,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPinCategories = `-- name: GetPinCategories :many
SELECT id, name, deleted_at, created_at, updated_at FROM pins_category WHERE deleted_at IS NULL ORDER BY id
`

func (q *Queries) GetPinCategories(ctx context.Context) ([]PinsCategory, error) {
	rows, err := q.db.Query(ctx, getPinCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PinsCategory
	for rows.Next() {
		var i PinsCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPinCategory = `-- name: GetPinCategory :one
SELECT id, name, deleted_at, created_at, updated_at FROM pins_category WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetPinCategory(ctx context.Context, id int32) (PinsCategory, error) {
	row := q.db.QueryRow(ctx, getPinCategory, id)
	var i PinsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPins = `-- name: GetPins :many
SELECT id, event_date, image_pin, pin_title, pin_description, auto_assigned, category_id, deleted_at, created_at, updated_at FROM pins WHERE deleted_at IS NULL ORDER BY id
`

func (q *Queries) GetPins(ctx context.Context) ([]Pin, error) {
	rows, err := q.db.Query(ctx, getPins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Pin
	for rows.Next() {
		var i Pin
		if err := rows.Scan(
			&i.ID,
			&i.EventDate,
			&i.ImagePin,
			&i.PinTitle,
			&i.PinDescription,
			&i.AutoAssigned,
			&i.CategoryID,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertEmployeePin = `-- name: InsertEmployeePin :one
INSERT INTO employee_pins (
    employee_id, pin_id, category_id, deleted_at, created_at, updated_at
) VALUES (
    $1, $2, $3, NULL, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING employee_id, pin_id, category_id, deleted_at, created_at, updated_at
`

type InsertEmployeePinParams struct {
	EmployeeID int32
	PinID      int32
	CategoryID int32
}

func (q *Queries) InsertEmployeePin(ctx context.Context, arg InsertEmployeePinParams) (EmployeePin, error) {
	row := q.db.QueryRow(ctx, insertEmployeePin, arg.EmployeeID, arg.PinID, arg.CategoryID)
	var i EmployeePin
	err := row.Scan(
		&i.EmployeeID,
		&i.PinID,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteEmployeePin = `-- name: SoftDeleteEmployeePin :one
UPDATE employee_pins SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE employee_id = $1 AND pin_id = $2 AND deleted_at IS NULL
RETURNING employee_id, pin_id, category_id, deleted_at, created_at, updated_at
`

type SoftDeleteEmployeePinParams struct {
	EmployeeID int32
	PinID      int32
}

func (q *Queries) SoftDeleteEmployeePin(ctx context.Context, arg SoftDeleteEmployeePinParams) (EmployeePin, error) {
	row := q.db.QueryRow(ctx, softDeleteEmployeePin, arg.EmployeeID, arg.PinID)
	var i EmployeePin
	err := row.Scan(
		&i.EmployeeID,
		&i.PinID,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeleteEmployeePinByCategoryID = `-- name: SoftDeleteEmployeePinByCategoryID :exec
UPDATE employee_pins SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE category_id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteEmployeePinByCategoryID(ctx context.Context, categoryID int32) error {
	_, err := q.db.Exec(ctx, softDeleteEmployeePinByCategoryID, categoryID)
	return err
}

const softDeletePin = `-- name: SoftDeletePin :one
UPDATE pins SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, event_date, image_pin, pin_title, pin_description, auto_assigned, category_id, deleted_at, created_at, updated_at
`

func (q *Queries) SoftDeletePin(ctx context.Context, id int32) (Pin, error) {
	row := q.db.QueryRow(ctx, softDeletePin, id)
	var i Pin
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.ImagePin,
		&i.PinTitle,
		&i.PinDescription,
		&i.AutoAssigned,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const softDeletePinCategory = `-- name: SoftDeletePinCategory :exec
UPDATE pins_category SET
    deleted_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeletePinCategory(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, softDeletePinCategory, id)
	return err
}

const updatePin = `-- name: UpdatePin :one
UPDATE pins
SET
    event_date = COALESCE($2, event_date),
    image_pin = COALESCE($3, image_pin),
    pin_title = COALESCE($4, pin_title),
    pin_description = COALESCE($5, pin_description),
    auto_assigned = COALESCE($6, auto_assigned),
    category_id = COALESCE($7, category_id),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, event_date, image_pin, pin_title, pin_description, auto_assigned, category_id, deleted_at, created_at, updated_at
`

type UpdatePinParams struct {
	ID             int32
	EventDate      pgtype.Date
	ImagePin       pgtype.Text
	PinTitle       pgtype.Text
	PinDescription pgtype.Text
	AutoAssigned   pgtype.Bool
	CategoryID     pgtype.Int4
}

func (q *Queries) UpdatePin(ctx context.Context, arg UpdatePinParams) (Pin, error) {
	row := q.db.QueryRow(ctx, updatePin,
		arg.ID,
		arg.EventDate,
		arg.ImagePin,
		arg.PinTitle,
		arg.PinDescription,
		arg.AutoAssigned,
		arg.CategoryID,
	)
	var i Pin
	err := row.Scan(
		&i.ID,
		&i.EventDate,
		&i.ImagePin,
		&i.PinTitle,
		&i.PinDescription,
		&i.AutoAssigned,
		&i.CategoryID,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePinCategory = `-- name: UpdatePinCategory :one
UPDATE pins_category
SET
    name = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, name, deleted_at, created_at, updated_at
`

type UpdatePinCategoryParams struct {
	ID   int32
	Name string
}

func (q *Queries) UpdatePinCategory(ctx context.Context, arg UpdatePinCategoryParams) (PinsCategory, error) {
	row := q.db.QueryRow(ctx, updatePinCategory, arg.ID, arg.Name)
	var i PinsCategory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
